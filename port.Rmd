---
title: "time_series_report"
author: "Román Landa"
date: "2024-10-29"
output: html_document
---

PREDICCIONES PARA EL ESTIMADOR MENSUAL DE ACTIVIDAD ECONÓMICA

# Intrducción

El Estimador mensual de actividad económica (EMAE) refleja la evolución mensual de la actividad económica del conjunto de los sectores productivos a nivel nacional. Este es un indicador provisorio de la evolución del PIB a precios constantes de 2004 que será difundido con un rezago de 50 a 60 días de concluido el mes de referencia.

El indicador es un índice Laspeyres que ofrece una pauta del comportamiento de la actividad económica real con 
una frecuencia mayor a la del PIB trimestral a precios constantes. Su cálculo se estructura en la agregación del valor agregado a precios básicos de cada una de las actividades económicas más los impuestos netos de subsidios a los productos, utilizando las ponderaciones de las cuentas nacionales base 2004 de la República Argentina. Se trata de replicar los métodos de cálculo del PIB trimestral y/o anual, en la medida en que lo permite la disponibilidad de fuentes de información para un período más corto.

Es necesario enfatizar que el EMAE se elabora con información parcial, de carácter provisorio -dado que en algunos
casos es corregida y/o completada por la fuente- o con indicadores alternativos a los que se utilizan para el cálculo trimestral, en tanto se han evaluado como adecuadas aproximaciones a éstos. Dado que la estimación del PIB trimestral reúne mayor cantidad de datos, por cerrarse y difundirse unos 30 días después que el EMAE, es habitual que se observen diferencias entre las variaciones trimestrales de ambos indicadores.

# Objetivo

El objetivo de este informe es aplicar de manera práctica las herramientas analíticas adquiridas en la cátedra de Series de Tiempo, mediante un análisis descriptivo y predictivo de series temporales reales. Se busca así fortalecer la comprensión de los métodos estudiados y su aplicación en datos económicos, evaluando tanto las tendencias históricas como las posibles proyecciones del comportamiento económico en el corto y mediano plazo.

# Bibliografia

Tanto en la cátedra como en este trabajo nos basamos el los libros:

* ![Forecasting: Principles and Practice (3rd ed)](https://otexts.com/fpp3/) de Rob J Hyndman and George Athanasopoulos

* Time Series Analysis: Univariate and Multivariate Methods (2nd er) de Wiliam Wei

# Data

La API de Series de Tiempo de Argentina, permite consultar indicadores con evolución cronológica publicados en formatos abiertos por organismos de la Administración Pública Nacional. Haremos uso de dicha API para traeros la serie [EMAE. Base 2004](https://datos.gob.ar/series/api/series/?ids=143.3_NO_PR_2004_A_21)

```{r}
source("enviroment.R")
# API EMAE datos.gob
emae_mensual <- read.csv("https://infra.datos.gob.ar/catalog/sspm/dataset/143/distribution/143.3/download/emae-valores-anuales-indice-base-2004-mensual.csv")
```



```{r}
# Extrae el año
emae_mensual$indice_tiempo <- as.Date(emae_mensual$indice_tiempo, format = "%Y-%m-%d") 
emae_mensual$year <- year(emae_mensual$indice_tiempo)
emae_mensual$periodo <- format(emae_mensual$indice_tiempo, "%Y-%m")
```

Vemos que actualmente tenemos valores publicados hasta el mes de Agosto 2024. Decidimos guardaremos todos los meses de dicho año para luego comparar con nuestras predicicones

```{r}
values_to_predict <- tail(emae_mensual$emae_original, 8)
# Eliminar los últimos 8 registros de emae_mensual
emae_mensual <- emae_mensual[1:(nrow(emae_mensual) - 8), ]
```

```{r}
emae_mensual$year_factor <- as.factor(emae_mensual$year)
# Creo un Time Serie object
emae_mensual_ts <- emae_mensual %>%
  mutate(periodo = yearmonth(periodo)) %>%  
  as_tsibble(index = periodo)
```

# Identificación de Serie

```{r}
ggplot(emae_mensual_ts, aes(x = indice_tiempo, y = emae_original)) + 
  geom_line() +
  labs(title = "Serie de Tiempo EMAE (2010-2020)", x = "Fecha", y = "Valor") +
  theme_minimal()
```

Grafico además un box plot por año, para ver si la variancia es constante.

```{r}
ggplot(emae_mensual_ts, aes(x = year_factor, y = emae_original)) +
  geom_boxplot() +
  labs(title = "Boxplot de Valores por Año (2010-2020)", x = "Año", y = "EMAE") +
  theme_minimal() # no tiene variancia constante
```
Si tenemo en cuenta los outlier la variancia luce parecida a lo largo de los años, pero esto es solo una aproximacion grafica, como no tenemos certeza realizamos el grafico de box y cox para probar posibles transformaicones


## Transformación

```{r}
boxcox(lm(data = emae_mensual_ts, emae_original ~ 1), plotit = T, lambda = seq(-3, 8, by = 0.5))
```
```{r}
# Parámetro lambda
lambda <- 3
# Aplicar la transformación
emae_mensual_ts <- emae_mensual_ts %>%
  mutate(emae_transformed = (emae_original^lambda - 1) / lambda)
```

```{r}
ggplot(emae_mensual_ts, aes(x = year_factor, y = emae_transformed)) +
  geom_boxplot() +
  labs(title = "Boxplot de Valores por Año (2010-2020)", x = "Año", y = "EMAE") +
  theme_minimal() # no tiene variancia constante
```


## Diferenciaciones

Vemos que la serie presenta una estacionaridad marcada año tras año, es por esto que decidimos diferenciar esa parte 

```{r}
emae_mensual_ts %>% 
  gg_tsdisplay(difference(emae_original, 12), 
               plot_type='partial',
               lag=36)
```
Por los graficos de FAC y FACP podemos notar una forma de AR(1) en la parte regular, tal vez, si consideramos significativos los rezagos 2 y 3 de la FACP y viendo la caida sinusoidal de la FAC podriamos decir que es hasta un AR(3), pero nos quedamo con el modelo mas sencilo.
Para la parte estacionaria, vinedo los rezagos 12 y 24, podemos suponer luego de una diferenciación un modelo ARIMA(1,1,0) o ARIMA(2,1,0) 

## Ajuste de Serie

```{r}
# Definir nombres de archivo para guardar los modelos
fit_original_file <- "fitted/fit_original.rds"
fit_transformed_file <- "fitted/fit_transformed.rds"

# Ajuste y guardado de fit_original
NOTFIT = TRUE
if (NOTFIT) {
  fit_original <- readRDS(fit_original_file)
  message("Modelo fit_original cargado desde el archivo.")
} else {
  fit_original <- emae_mensual_ts %>% 
    model(
      arima11 = ARIMA(emae_original ~ pdq(1,0,0) + PDQ(1,1,0)),
      arima11_2 = ARIMA(emae_original ~ pdq(1,0,0) + PDQ(2,1,0)),
      auto = ARIMA(emae_original, stepwise = FALSE, approx = FALSE),
      auto_2 = ARIMA(emae_original, stepwise = TRUE, approx = TRUE)
    )
  saveRDS(fit_original, fit_original_file)
  message("Modelo fit_original ajustado y guardado en el archivo.")
}

# Ajuste y guardado de fit_transformed
if (NOTFIT) {
  fit_transformed <- readRDS(fit_transformed_file)
  message("Modelo fit_transformed cargado desde el archivo.")
} else {
  fit_transformed <- emae_mensual_ts %>% 
    model(
      arima11_t = ARIMA(emae_transformed ~ pdq(1,0,0) + PDQ(1,1,0)),
      arima11_t_2 = ARIMA(emae_transformed ~ pdq(1,0,0) + PDQ(2,1,0)),
      auto_trans = ARIMA(emae_transformed, stepwise = FALSE, approx = FALSE),
      auto_trans_2 = ARIMA(emae_transformed, stepwise = TRUE, approx = TRUE)
    )
  saveRDS(fit_transformed, fit_transformed_file)
  message("Modelo fit_transformed ajustado y guardado en el archivo.")
}
```
## Elección de Serie

```{r}
fit_original |> pivot_longer(everything(), names_to = "Model name",
                    values_to = "Orders")
```

```{r}
fit_transformed |> pivot_longer(everything(), names_to = "Model name",
                    values_to = "Orders")
```

```{r}
rbind(glance(fit_original),glance(fit_transformed))
```

Lo primero que vemos aqui es que los modelos de la serie no transformada ajustan mucho mejor a los datos.
Como sospechabamos, la serie no necesita de una transformación, aunque seguiremos testeando esto a lo largo
del informe. También podemos ver que el mejor modelo es el ajustado automaticamente, un SARIMA(0,1,2)(2,1,2)[12], diferenciado una vez en la parte estacional y una vez en la parte regular. Este será el modelo con el que continuaremos trabajando.

# Diagnostico del Modelo

Previo a realizar predicciones necesitamos comprobar algunos supuestos para los $\hat{a_t}=Z_t - \hat{Z_{t}}$ de nuestra serie:

* $E(a_t)=0$.

* $V(a_t)=\sigma_a^2$ constante.

* *Sean incorrelados.*

* Se distribuyan asintóticamente $N(0,\sigma_a^2)$.

Comenzaremos con un grafico de Residuos vs Timepo para comprobar esperanza y variancia constante

```{r}
# Extraer los residuos del modelo "auto"
residuos <- residuals(fit_original, type = "response") %>%
  filter(.model == "auto")  # Seleccionar el modelo "auto"

# Graficar los residuos vs tiempo
g1 <- ggplot(residuos, aes(x = periodo, y = .resid)) +
  geom_point(color = "cyan4") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  labs(
    title = "Residuos del modelo SARIMA(0,1,2)(2,1,2)[12] ajustado",
    x = "",
    y = "Residuos"
  ) +
  theme_minimal()
ggplotly(g1)
```

Vemos aqui marcados outliers en Marzo y Abril 2020, inicio de la pandemia causada por el covid-19. Obviando estos valores, los residuos parecen constantes y centrados en cero.

Continuamos nuestro analisis con el mas importante de los supuestos. Miraremos el grafico de autocorrelacion para los residuos, esperando que estos esten incorrelados

```{r}
# Gráfico de autocorrelación para los residuos
acf(residuos$.resid, main = "Autocorrelación de los residuos", lag.max = 48)

# Convertir autocorrelaciones en un DataFrame para graficarlas con ggplot
# acf_data <- acf(residuos$.resid, plot = FALSE)
# acf_df <- data.frame(
#   Lag = acf_data$lag,
#   ACF = acf_data$acf
# )
# 
# # Graficar autocorrelación con ggplot
# acf_plot <- ggplot(acf_df, aes(x = Lag, y = ACF)) +
#   geom_bar(stat = "identity", fill = "blue", alpha = 0.7) +
#   geom_hline(yintercept = 0, color = "black") +
#   geom_hline(yintercept = c(-1.96 / sqrt(length(residuos$.resid)), 
#                             1.96 / sqrt(length(residuos$.resid))), 
#              linetype = "dashed", color = "red") +
#   labs(
#     title = "Autocorrelación de los residuos",
#     x = "Desfase (Lag)",
#     y = "Autocorrelación"
#   ) +
#   theme_minimal()
```
```{r}
#TODO: test para los rezagos

```

Como podemos observar, los residuos son ruido blanco, por lo que solo nos queda comprobar el supuesto de distribución asintotica normal para poder realizar intervalos de confianza a nuestras predicciones

```{r}
# Histograma de los residuos
h <- ggplot(residuos, aes(x = .resid)) +
  geom_histogram(aes(y = ..density..), bins = 30, fill = "cyan4", alpha = 0.7) +
  geom_density(color = "red", size = 1) +
  labs(
    title = "Histograma de los residuos",
    x = "Residuos",
    y = "Densidad"
  ) +
  theme_minimal()

# QQ-Plot normal
qq <- ggplot(residuos, aes(sample = .resid)) +
  stat_qq(color = "cyan4") +
  stat_qq_line(color = "red", linetype = "dashed") +
  labs(
    title = "QQ-Plot de los residuos",
    x = "Cuantiles teóricos",
    y = "Cuantiles de los residuos"
  ) +
  theme_minimal()

h/qq
```
Vemos que a causa de los outliers la distribución de los residuos es asimétrica

```{r}
#shapiro.test(residuos$.resid)
```


# Predicción

```{r}
f <- forecast(fit_original, h = 8) |>
  filter(.model == 'auto') |>
  autoplot(emae_mensual_ts) + # Asegúrate de que emae_mensual_ts sea tu serie original
  autolayer(emae_mensual_ts, series = "Serie Original", color = "cyan4") + # Añade la serie original
  labs(
    title = "EMAE con predicciones del modelo ARIMA",
    y = "Número de personas (millones)",
    x = "Tiempo"
  ) +
  theme_minimal() +
  theme(legend.title = element_blank())
f
```

```{r}
ggplotly(f)
```



