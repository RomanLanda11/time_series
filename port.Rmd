---
title: "SERIES DE TIEMPO: Estimador Mensual de Actividad Económica Argentina"
author: "LANDA, Román"
date: "`r Sys.Date()`"
output:
  rmdformats::material:
    self_contained: true
    code_folding: hide
    lightbox: true
    thumbnails: true
    highlight: kate
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  fig.width = 7, 
  fig.height = 5, 
  echo = TRUE, 
  warning = FALSE,
  message = FALSE,
  #out.width = "100%"
)
```

# Intrducción

El Estimador mensual de actividad económica (EMAE) refleja la evolución mensual de la actividad económica del conjunto de los sectores productivos a nivel nacional. Este es un indicador provisorio de la evolución del PIB a precios constantes de 2004 que será difundido con un rezago de 50 a 60 días de concluido el mes de referencia.

El indicador es un índice Laspeyres que ofrece una pauta del comportamiento de la actividad económica real con 
una frecuencia mayor a la del PIB trimestral a precios constantes. Su cálculo se estructura en la agregación del valor agregado a precios básicos de cada una de las actividades económicas más los impuestos netos de subsidios a los productos, utilizando las ponderaciones de las cuentas nacionales base 2004 de la República Argentina. Se trata de replicar los métodos de cálculo del PIB trimestral y/o anual, en la medida en que lo permite la disponibilidad de fuentes de información para un período más corto.

Es necesario enfatizar que el EMAE se elabora con información parcial, de carácter provisorio -dado que en algunos
casos es corregida y/o completada por la fuente- o con indicadores alternativos a los que se utilizan para el cálculo trimestral, en tanto se han evaluado como adecuadas aproximaciones a éstos. Dado que la estimación del PIB trimestral reúne mayor cantidad de datos, por cerrarse y difundirse unos 30 días después que el EMAE, es habitual que se observen diferencias entre las variaciones trimestrales de ambos indicadores.

# Objetivo

El objetivo de este informe es aplicar de manera práctica las herramientas analíticas adquiridas en la cátedra de Series de Tiempo, mediante un análisis descriptivo y predictivo de series temporales reales. Se busca así fortalecer la comprensión de los métodos estudiados y su aplicación en datos económicos, evaluando tanto las tendencias históricas como las posibles proyecciones del comportamiento económico en el corto y mediano plazo.


# Datos

La API de Series de Tiempo de Argentina, permite consultar indicadores con evolución cronológica publicados en formatos abiertos por organismos de la Administración Pública Nacional. Haremos uso de dicha API para traeros la serie [EMAE. Base 2004](https://datos.gob.ar/series/api/series/?ids=143.3_NO_PR_2004_A_21)


```{r}
source("enviroment.R")
# API EMAE datos.gob
emae_mensual <- read.csv("https://infra.datos.gob.ar/catalog/sspm/dataset/143/distribution/143.3/download/emae-valores-anuales-indice-base-2004-mensual.csv")

# Extrae el año
emae_mensual$indice_tiempo <- as.Date(emae_mensual$indice_tiempo, format = "%Y-%m-%d") 
emae_mensual$year <- year(emae_mensual$indice_tiempo)
emae_mensual$periodo <- format(emae_mensual$indice_tiempo, "%Y-%m")
```


Vemos que actualmente tenemos valores publicados hasta el mes de Agosto 2024. Decidimos guardaremos todos los meses de dicho año para luego comparar con nuestras predicicones

```{r}
values_to_predict <- tail(emae_mensual$emae_original, 8)
# Eliminar los últimos 8 registros de emae_mensual
emae_mensual <- emae_mensual[1:(nrow(emae_mensual) - 8), ]

emae_mensual$year_factor <- as.factor(emae_mensual$year)
# Creo un Time Serie object
emae_mensual_ts <- emae_mensual %>%
  mutate(periodo = yearmonth(periodo)) %>%  
  as_tsibble(index = periodo)
```

# Identificación de Serie

En primer instancia querremos usar nuestros conocimientos para identificar un modelo que ajuste correctamente a nuestros datos de forma "manual". Es por esto que comenzamos observando la evolución del EMAE en el tiempo (con base 100 al inicio de 2004)

```{r, fig.width=5, fig.height=3}
s1 <- ggplot(emae_mensual_ts, aes(x = indice_tiempo, y = emae_original)) + 
  geom_line(color = "cyan4") +
  labs(title = "Serie de Tiempo EMAE", x = "Fecha", y = "Indice 2004 = 100") +
  theme_minimal()
ggplotly(s1)
```

Tambien se grafica un box plot por año, para ver si la variancia es constante.

```{r, fig.width=7, fig.height=4}
ggplot(emae_mensual_ts, aes(x = year_factor, y = emae_original)) +
  geom_boxplot(fill = "cyan4") +
  labs(title = "Boxplot de Valores por Año", x = "Año", y = 'Indice 2004 = 100') +
  theme_minimal() # no tiene variancia constante
```
Si tenemo en cuenta los outlier la variancia luce parecida a lo largo de los años, pero esto es solo una aproximacion gráfica, como no tenemos certeza realizamos el grafico de Box y Cox para probar posibles transformaicones


## Transformación

Sabemos que una de las formas de estabilizar la variancia en nuestra serie es realizando alguna transformación como lo son la *logarítmica* o *cuadrática*. 
Se probaron algunas transformaciones en la serie pero ninguna parecia tener una implicancia positiva en la estabilizacion de la variancia, por ello se decidió presentar la transformacion recomendad por el gráfico de Box y Cox solo a modo de ejemplo

```{r}
boxcox(lm(data = emae_mensual_ts, emae_original ~ 1), 
       plotit = T, 
       lambda = seq(-3, 8, by = 0.5))
```
```{r}
# Parámetro lambda
lambda <- 3
# Aplicar la transformación
emae_mensual_ts <- emae_mensual_ts %>%
  mutate(emae_transformed = (emae_original^lambda - 1) / lambda)

ggplot(emae_mensual_ts, aes(x = year_factor, y = emae_transformed)) +
  geom_boxplot(fill="cyan4") +
  labs(title = "Boxplot de Valores por Año", x = "Año", y = 'Indice 2004 = 100') +
  theme_minimal() # no tiene variancia constante
```
Como mencionamos anteriormente, esta transformación solo parece cambiar la escala pero no la forma de la variancia anual, por lo que continuaremos nuestro trabajo con la serie original.

## Diferenciaciones

Al analizar la serie temporal del EMAE, observamos un patrón de estacionalidad recurrente, donde las fluctuaciones anuales se mantienen consistentemente a lo largo del tiempo. Para abordar este comportamiento y trabajar con una serie estacionaria (requisito fundamental para los modelos ARIMA), decidimos aplicar una diferenciación estacional. Este proceso nos permite eliminar los componentes estacionales y centrar nuestro análisis en las variaciones más relevantes de la tendencia y los ciclos.

```{r}
emae_mensual_ts %>% 
  gg_tsdisplay(difference(emae_original, 12), 
               plot_type='partial',
               lag=36)
```
Al analizar los gráficos de la Función de Autocorrelación (FAC) y la Función de Autocorrelación Parcial (FACP), identificamos características que sugieren un modelo autorregresivo (AR) en la parte regular de la serie. En particular:

* La FAC muestra una caída exponencial y un patrón sinusoidal, característico de un modelo AR.

* La FACP resalta significancia en los rezagos 2 y 3, lo que podría apuntar a un modelo $AR(3)$. Sin embargo, optamos por el modelo más sencillo, $AR(1)$, para mantener la parsimonia.

Para la parte estacional, observamos picos significativos en los rezagos 12 y 24, lo que indica una estacionalidad anual bien definida. Luego de aplicar una diferenciación estacional, consideramos los siguientes modelos como candidatos:

* $ARIMA(1,1,0)$: Un modelo simple que captura la dinámica principal.

* $ARIMA(2,1,0)$: Una extensión que podría reflejar interacciones adicionales entre rezagos.

Finalmente, la selección del modelo se basará en criterios de ajuste como AIC, BIC y análisis de residuos para garantizar un balance la bondad de ajuste y lo parsimoñoso del modelo.


## Ajuste de la Serie

A partir del análisis previo de los gráficos de la FAC y la FACP, identificamos posibles configuraciones para los modelos ARIMA que se ajustan tanto a la parte regular como a la estacional de la serie. Con base en estos hallazgos, y para garantizar un análisis robusto, procederemos a ajustar los modelos identificados de dos maneras:

* **Modelos identificados manualmente:** Utilizaremos las configuraciones sugeridas (por ejemplo, $ARIMA(1,1,0)$ y $ARIMA(2,1,0)$) como punto de partida para verificar su desempeño en el ajuste de la serie.

* **Modelos automáticos:** Exploraremos opciones generadas automáticamente mediante métodos de selección óptimos basados en criterios como AIC y BIC, que evalúan el balance entre la complejidad del modelo y su capacidad de predicción.

De esta manera, compararemos los resultados de ambos enfoques para determinar cuál ofrece el mejor ajuste y predicción, siempre considerando la parsimonia y la calidad de los residuos.

```{r}
# Definir nombres de archivo para guardar los modelos
fit_original_file <- "fitted/fit_original.rds"
fit_transformed_file <- "fitted/fit_transformed.rds"

# Ajuste y guardado de fit_original
NOTFIT = TRUE
if (NOTFIT) {
  fit_original <- readRDS(fit_original_file)
  message("Modelo fit_original cargado desde \fitted.")
} else {
  fit_original <- emae_mensual_ts %>% 
    model(
      arima11 = ARIMA(emae_original ~ pdq(1,0,0) + PDQ(1,1,0)),
      arima11_2 = ARIMA(emae_original ~ pdq(1,0,0) + PDQ(2,1,0)),
      auto = ARIMA(emae_original, stepwise = FALSE, approx = FALSE),
      auto_2 = ARIMA(emae_original, stepwise = TRUE, approx = TRUE)
    )
  saveRDS(fit_original, fit_original_file)
  message("Modelo fit_original ajustado y guardado en \fitted.")
}

# # Ajuste y guardado de fit_transformed
# if (NOTFIT) {
#   fit_transformed <- readRDS(fit_transformed_file)
#   message("Modelo fit_transformed cargado desde el archivo.")
# } else {
#   fit_transformed <- emae_mensual_ts %>% 
#     model(
#       arima11_t = ARIMA(emae_transformed ~ pdq(1,0,0) + PDQ(1,1,0)),
#       arima11_t_2 = ARIMA(emae_transformed ~ pdq(1,0,0) + PDQ(2,1,0)),
#       auto_trans = ARIMA(emae_transformed, stepwise = FALSE, approx = FALSE),
#       auto_trans_2 = ARIMA(emae_transformed, stepwise = TRUE, approx = TRUE)
#     )
#   saveRDS(fit_transformed, fit_transformed_file)
#   message("Modelo fit_transformed ajustado y guardado en el archivo.")
# }

fit_original |> pivot_longer(everything(), names_to = "Model name",
                    values_to = "Orders")

glance(fit_original)
```

De la tabla presentada, obtenemos las siguientes observaciones clave:

1. El mejor modelo identificado es el ajustado automáticamente, $SARIMA(0,1,2)(2,1,2)_{12}$. Este modelo utiliza una diferenciación y un comportamiento $MA(2)$ en la parte regular y una diferenciación y un comportamiento $ARMA(2,2)$ en la parte estacional.

2. El modelo $SARIMA(1,0,0)(2,1,0)_{(12)}$ presenta un desempeño competitivo y será considerado como una alternativa más sencilla para comparación.

A partir de estas conclusiones, trabajaremos con ambos modelos ($SARIMA(0,1,2)(2,1,2)_{12}$. y $SARIMA(1,0,0)(2,1,0)_{(12)}$) en las siguientes etapas del análisis, evaluando su desempeño en términos de ajuste y predicción.


### Modelos

```{r}
# Extraer parámetros de los modelos ajustados
fit_original %>%
  tidy() %>%  # Extraer parámetros en formato legible
  select(.model, term, estimate)%>%
  filter(.model %in% c("auto", "arima11_2"))
```
Los modelos estimados con los que trabajaremos se notan como:

$$ SARIMA(1,0,0)(2,1,0)_{(12)} \Rightarrow (1-0,92B)(1+0,5B^{12}+0,29B^{13})(1-B^{12})Z_t=a_t $$
$$ SARIMA(0,1,2)(2,1,2)_{12} \Rightarrow  (1-0,79B^{12}+0,42B^{13})(1-B)(1-B^{12})Z_t=(1-0,97B+0,96B^2)(1+1,46B^{12}-0,69B^{13})a_t  $$
Para cerrar esta sección se presenta un grafico interactivo que nos permite dilusidar lo parecido y lo preciso de ambos modelos para los ultimos 4 años.

```{r}
#TODO: como hago para ver los phi y teta estimados?


fitted_values <- fitted_values %>%
  mutate(periodo_date = parse_date_time(periodo, orders = "Y b")) # Convierte fecha

fitted_values_filtered <- fitted_values %>%
  filter(
    periodo_date >= ymd("2019-01-01") & periodo_date <= ymd("2024-12-31"),
    .model %in% c("auto", "arima11_2") # Filtrar modelos
  )

# Graficar los valores filtrados
g <- ggplot(data = fitted_values_filtered, aes(x = periodo_date)) +
  geom_line(aes(y = emae_original, color = "Serie Original"), size = 1) +
  geom_line(aes(y = .fitted, color = .model), linetype = "dashed", size = 0.8) +
  labs(
    title = "Serie Original y Estimaciones de los Modelos (2019-2024)",
    x = "Tiempo",
    y = "Índice 2004 = 100",
    color = "Leyenda"
  ) +
  theme_minimal() +
  scale_color_manual(values = c("Serie Original" = "cyan4", "arima11_2" = "green4", "auto" = "purple4"))
ggplotly(g)
```


# Diagnostico del Modelo

Antes de proceder con las predicciones, es fundamental verificar que los residuos del modelo, definidos como $\hat{a_t}=Z_t - \hat{Z_{t}}$ cumplan con los supuestos planteados a la hora de hacer el ajuste:

1. $E(a_t)=0$. Los residuos deben tener media cero.

2. $V(a_t)=\sigma_a^2$. La varianza de los residuos debe ser constante a lo largo del tiempo.

3. **Independencia.** Los residuos deben ser incorrelados.

4. $a_t \sim N(0,\sigma_a^2)$.Los residuos deben seguir una distribución asintóticamente Normal.

Comenzaremos con un gráfico de Residuos vs Timepo para comprobar esperanza y variancia constante

```{r}
#TODO: Hace falta ver errores standard?

# Extraer los residuos del modelo "auto"
residuos1 <- residuals(fit_original, type = "response") %>%
  filter(.model == "auto")  #  modelo "auto"
residuos2 <- residuals(fit_original, type = "response") %>%
  filter(.model == "arima11_2")  #arima11_2

# Graficar los residuos vs tiempo
g1 <- ggplot(residuos1, aes(x = periodo, y = .resid)) +
  geom_point(color = "cyan4") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  labs(
    title = "Residuos SARIMA(0,1,2)(2,1,2)[12]",
    x = "",
    y = "Residuos"
  ) +
  theme_minimal()
g2 <- ggplot(residuos2, aes(x = periodo, y = .resid)) +
  geom_point(color = "cyan4") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  labs(
    title = "Residuos SARIMA(1,0,0)(2,1,0)[12]",
    x = "",
    y = "Residuos"
  ) +
  theme_minimal()
g1+g2
```

Vemos aqui marcados outliers en Marzo y Abril 2020, inicio de la pandemia causada por el covid-19. Obviando estos valores, los residuos parecen tener variancia constantes y estar centrados en cero.

Continuamos nuestro analisis con el mas importante de los supuestos. Miraremos el grafico de autocorrelacion para los residuos, esperando que estos esten incorrelados

```{r}
# Gráfico de autocorrelación para los residuos
r1 <- acf(residuos1$.resid, main = "Autocorrelación de los residuos", lag.max = 48)
r2 <- acf(residuos2$.resid, main = "Autocorrelación de los residuos", lag.max = 48)
# Convertir autocorrelaciones en un DataFrame para graficarlas con ggplot
# acf_data <- acf(residuos$.resid, plot = FALSE)
# acf_df <- data.frame(
#   Lag = acf_data$lag,
#   ACF = acf_data$acf
# )
# 
# # Graficar autocorrelación con ggplot
# acf_plot <- ggplot(acf_df, aes(x = Lag, y = ACF)) +
#   geom_bar(stat = "identity", fill = "blue", alpha = 0.7) +
#   geom_hline(yintercept = 0, color = "black") +
#   geom_hline(yintercept = c(-1.96 / sqrt(length(residuos$.resid)), 
#                             1.96 / sqrt(length(residuos$.resid))), 
#              linetype = "dashed", color = "red") +
#   labs(
#     title = "Autocorrelación de los residuos",
#     x = "Desfase (Lag)",
#     y = "Autocorrelación"
#   ) +
#   theme_minimal()
r1+r2
#TODO: ya descarto el modelo manual?
```

```{r}
#TODO: test para los rezagos

```

Como podemos observar, los residuos son ruido blanco, por lo que solo nos queda comprobar el supuesto de distribución asintotica normal para poder realizar intervalos de confianza a nuestras predicciones

```{r}
# Histograma de los residuos
h <- ggplot(residuos, aes(x = .resid)) +
  geom_histogram(aes(y = ..density..), bins = 30, fill = "cyan4", alpha = 0.7) +
  geom_density(color = "red", size = 1) +
  labs(
    title = "Histograma de los residuos",
    x = "Residuos",
    y = "Densidad"
  ) +
  theme_minimal()

# QQ-Plot normal
qq <- ggplot(residuos, aes(sample = .resid)) +
  stat_qq(color = "cyan4") +
  stat_qq_line(color = "red", linetype = "dashed") +
  labs(
    title = "QQ-Plot de los residuos",
    x = "Cuantiles teóricos",
    y = "Cuantiles de los residuos"
  ) +
  theme_minimal()

h/qq
```
Vemos que a causa de los outliers la distribución de los residuos es asimétrica



# Predicción

```{r}
f <- forecast(fit_original, h = 8) |>
  filter(.model == 'auto') |>
  autoplot(emae_mensual_ts) + # Asegúrate de que emae_mensual_ts sea tu serie original
  autolayer(emae_mensual_ts, series = "Serie Original", color = "cyan4") + # Añade la serie original
  labs(
    title = "EMAE con predicciones del modelo ARIMA",
    y = "Número de personas (millones)",
    x = "Tiempo"
  ) +
  theme_minimal() +
  theme(legend.title = element_blank())
f
```

```{r}
#TODO: Comparo dos modelos?
```

# Discusión

# Bibliografia

Tanto en la cátedra como en este trabajo nos basamos el los libros:

* [Forecasting: Principles and Practice (3rd ed)](https://otexts.com/fpp3/) de Rob J Hyndman and George Athanasopoulos

* Time Series Analysis: Univariate and Multivariate Methods (2nd er) de Wiliam Wei

